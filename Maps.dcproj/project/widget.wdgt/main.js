/* 
 This file was generated by Dashcode.  
 You may edit this file to customize your widget or web page 
 according to the license.txt file included in the project.
 */


// Global variables
var map;                      // Global reference to the map Div
var geocoder;                 // Global geocoder
var infoWindow;               // Reference to the unique info window
var markersToAdd;             // Array of markers pending to add to the map
var totalMarkersInMap;        // Total number of markers currently in the map
var timeoutToCenterMap;       // Global timer to avoid re-centering the map repeatedly
var futureMapBounds;          // Bounds for map delayed re-centering
var futureMapCenter;          // Point for map delayed re-centering
var futureMapZoom;            // Zoom level for map delayed re-centering
var infoToCenter;             // Current distance from the info window to the center
var baseFeedURL;              // Base URL of the feed
var filters;                  // List of all the filters to apply to the feed
var hasCustomTitle;           // Flag to indicate if the map has a custom title
var shouldReloadMap;          // Flag to indicate that the map should be reloaded
var pendingRequests;          // Number of pending http requests
var showCalled;               // Flag that indicates the show() function has been called

// Define some URLs and namespaces commonly used in map feeds
var MAPS_BASE_SEARCH = "http://maps.google.com/maps?q=";
var NS_DC = "http://purl.org/dc/elements/1.1/";
var NS_CONTENT = "http://purl.org/rss/1.0/modules/content/";
var NS_XHTML = "http://www.w3.org/1999/xhtml";
var NS_WGS84 = "http://www.w3.org/2003/01/geo/wgs84_pos#";
var NS_GEORSS = "http://www.georss.org/georss";
var NS_GML = "http://www.opengis.net/gml";

// Dynamically load the Maps API with the specified developer key
if (attributes.googleMapsKey && attributes.googleMapsKey.length) {
    document.write('<' + 'script type="text/javascript" src="http://maps.google.com/maps?file=api&v=2&key=' + attributes.googleMapsKey + '"><' + '/script>');
    document.write('<' + 'script type="text/javascript" src="InfoWindow.js"><' + '/script>');
}

//
// Function: loadMapFromURL(url, redirectedFromHTML)
// Load map information from a URL and render it
//
// url: Absolute URL of the map source (KML or GeoRSS)
// redirectedFromHTML: Indicates that the function is being called after redirecting
//
function loadMapFromURL(url, redirectedFromHTML)
{
    if (!url || url.length == 0){
        return false;
    }
    
    // reformat the url
    url = url.replace(/^(feed:\/\/)/, "http://");
    if (url.indexOf("://") < 0) {
        url = "http://" + url;
    }
    
    // save the last loaded url
    attributes.lastMapURL = url;
    
    // show the Loading indicator
    setLoadingVisibility(true);

    // get the source file for the map and parse it
    var httpRequest = new XMLHttpRequest();
    httpRequest.onload = function (e) {
        // first check that the response is valid
        if (httpRequest.status != 200) {
            displayErrorMessage(dashcode.getLocalizedString("Fehler beim Abfragen der Karteninformationen."));
            setLoadingVisibility(false);
            return false;
        }

        var contentType = httpRequest.getResponseHeader("Content-Type") || "";
        var parsedDoc = null;
        // if it is an XML document
        if (contentType.indexOf("xml") > -1 || httpRequest.responseXML) {
            var docElement = httpRequest.responseXML.documentElement;
            if (docElement) {
                // if it is a KML document
                if (contentType.indexOf("kml") > -1 || findChild(docElement, "kml")) {
                    parsedDoc = parseKMLFeed(docElement, url);
                }
                // if it is an Atom document
                else if (docElement.tagName.toLowerCase() == "feed") {
                    parsedDoc = parseAtomFeed(docElement);
                }
                // if it is an RSS document
                else if (contentType.indexOf("rss") > -1 || findChild(docElement, "channel")) {
                    parsedDoc = parseRSSFeed(docElement);
                }
                // else, parse as a generic XML document
                else {
                    parsedDoc = parseXMLFeed(docElement, url);
                }           
            }
            else {
                displayErrorMessage(dashcode.getLocalizedString("Fehler beim Abfragen der Karteninformationen."));
            }
        }
        // if it is HTML
        else if (!redirectedFromHTML && contentType.indexOf("html") > -1) {
            // try to get the xml version (google maps "link to this page")
            url += "&output=nl"; // parameter that indicates google maps to send the kml version
            loadMapFromURL(url, true);
            parsedDoc = "redirected";
        }
            
        // if the document was successfully parsed, render it
        if (parsedDoc) {
            if (parsedDoc != "redirected") {
                renderMapOverlay(parsedDoc);
                displayErrorMessage("");
            }
        }
        else {
            displayErrorMessage(dashcode.getLocalizedString("Das Quelldokument konnte nicht verarbeitet werden."));
        }

        // if the map is loaded, hide the Loading indicator
        setLoadingVisibility(false);
    }
    // Send the request asynchronously
    httpRequest.open("GET", url);
    httpRequest.setRequestHeader("Cache-Control", "no-cache");
    httpRequest.send(null);
}

//
// Function: goToAddress(address)
// Center the map on a specified address
//
// address: Address to geocode and center in the map.
//
function goToAddress(address) {    
    if (geocoder && address && address.length) {
        // geocode the address
        setLoadingVisibility(true);
        geocoder.getLatLng(address, function (latLongPoint) {
            // when we get the result, move the map there
            if (latLongPoint) {
                futureMapBounds = null;
                futureMapCenter = latLongPoint;
                futureMapZoom = 14;
            }
            delayedCenterMapAddMarkers(-1);
            // hide the Loading indicator
            setLoadingVisibility(false);
        });
    }
}

//
// Function: displayErrorMessage(message, showGetKeyButton)
// Display an error message to the user.
//
// message: Text message to display
// showGetKeyButton: Show the "Get a Key" button
//
function displayErrorMessage(message, showGetKeyButton) {
    var messagesDiv = document.getElementById("messages");
    var messagesLabelDiv = document.getElementById("messagesLabel");
    if (messagesDiv && messagesLabelDiv) {
        messagesLabelDiv.innerHTML = message;
        fixLinks(messagesLabelDiv);
        if (message.length) {
            messagesDiv.style.visibility = "visible";
        }
        else {
            messagesDiv.style.visibility = "hidden";
        }
    }
    var getKeyButton = document.getElementById("getKeyButton");
    if (showGetKeyButton) {
        if (getKeyButton) {
            getKeyButton.style.visibility = "visible";
        }
    } else if(getKeyButton) {
        getKeyButton.style.visibility = "hidden";
    }
}


//
// Function: renderMapOverlay(parsedDoc) 
// Render a parsed map document as an overlay of the current map.
//
// parsedDoc: Parsed map document with placemarks
//
function renderMapOverlay(parsedDoc) 
{
    // clear the old markers
    markersToAdd = new Array();
    totalMarkersInMap = 0;
    map.clearOverlays();
    
    // update the title of the map
    if (!hasCustomTitle) {
        var mapTitle = document.getElementById("title");
        var mapURL;
        if (parsedDoc.feedType == "kml") {
            mapURL = MAPS_BASE_SEARCH+escape(attributes.lastMapURL);
        }
        else {
            mapURL = attributes.lastMapURL;
        }
        while (mapTitle.hasChildNodes()) mapTitle.removeChild(mapTitle.firstChild);
        var linkElement = document.createElement("a");
        linkElement.setAttribute("href", mapURL);
        linkElement.addEventListener("click", clickOnLink, false);
        linkElement.innerHTML = parsedDoc.name || "";
        if (mapTitle) mapTitle.appendChild(linkElement);
    }
    
    // process placemarks and create markers
    var totalExpectedMarkers = parsedDoc.placemarks.length;
    for(var pmIndex = 0; pmIndex < totalExpectedMarkers; pmIndex++) {
        var placemark = parsedDoc.placemarks[pmIndex];

        // define the icon for the marker
        var newIcon = null;
        var iconHref = null;
        // if it specifies a style
        if (placemark.styleUrl && placemark.styleUrl.indexOf("#")>-1) {
            var styleId = placemark.styleUrl.substring(placemark.styleUrl.indexOf("#")+1);
            var iconHref = parsedDoc.styles[styleId].iconHref;
        }
        // if it specifies the icon url
        else if (placemark.icon && placemark.icon.length) {
            iconHref = placemark.icon;
        }
        // if a URL for the icon was found, use it
        if (iconHref && iconHref.length) {
            newIcon = new GIcon();
            newIcon.image = iconHref;
            newIcon.iconSize = new GSize(32, 32);
            newIcon.iconAnchor = new GPoint(16, 32);
            newIcon.infoWindowAnchor = new GPoint(16, 0);
        }
        
        // if latitude and longitude was provided, add the marker immediately
        if (placemark.lat && placemark.lng) {
            addMarkerToMap(placemark, newIcon, totalExpectedMarkers);
        }
        // if an address is specified, geocode it and add the marker asynchronously
        else if (placemark.address && placemark.address.length) {
            addMarkerWithAddress(placemark, newIcon, totalExpectedMarkers);
        }
    }
}

//
// Function: addMarkerToMap(placemark, icon, totalExpectedMarkers)
// Create a marker and display it in the map.
//
// placemark: Structure that should contain attributes lat, lng, name, and description
// icon: Icon object (GIcon) to use for this marker
// totalExpectedMarkers: Total number of markers expected to be added
//
function addMarkerToMap(placemark, icon, totalExpectedMarkers) {
    // setup the marker
    var marker;
    var latLng = new GLatLng(placemark.lat, placemark.lng);
    if (icon) {
        marker = new GMarker(latLng, icon);
    }
    else {
        marker = new GMarker(latLng);
    }
    // save the original info
    marker.metaInfo_ = { 
        name: placemark.name,
        description: placemark.description,
        link: placemark.link
    };
            
    // event handling
    GEvent.addListener(marker, "click", function() {
        // setup the info window and show it
        if (infoWindow) {
            infoWindow.show(marker, attributes.reformatContent == 1);
        }    
    });

    // if it is the first marker, reset the map bounds
    if (totalMarkersInMap + markersToAdd.length == 0) {
        futureMapBounds = new GLatLngBounds();
    }
    // extend map bounds to include this point
    futureMapBounds.extend(latLng);
    
    // add the marker to the pending list
    markersToAdd.push(marker);

    // zoom/center the map to include all markers (delayed if it is not the last marker to add)
    var delayToCenter = 1000;
    if (totalExpectedMarkers == totalMarkersInMap + markersToAdd.length) {
        delayToCenter = -1;
    }
    delayedCenterMapAddMarkers(delayToCenter);
    
    return marker;
}

//
// Function: addMarkerWithAddress(placemark, icon, totalExpectedMarkers)
// Add a marker to the map by performing Geocoding from an address.
//
// placemark: Structure that should contain attributes address, name, and description
// icon: Icon object (GIcon) to use for this marker
// totalExpectedMarkers: Total number of markers expected to be added
//
function addMarkerWithAddress(placemark, icon, totalExpectedMarkers) {
    // geocode the address
    geocoder.getLatLng(placemark.address, function (latLongPoint) {
        // when we get the result, add the marker to the map
        if (latLongPoint) {
            placemark.lat = latLongPoint.lat();
            placemark.lng = latLongPoint.lng();
            addMarkerToMap(placemark, icon, totalExpectedMarkers);
        }
    });
}

//
// Function: delayedCenterMapAddMarkers(delay)
// Set the center in the map after a delay and add the pending markers
//
// delay: Miliseconds to wait before centering the map
//
function delayedCenterMapAddMarkers(delay) {
    // cancel the previous attempt to re-center the map
    if (timeoutToCenterMap) {
        clearTimeout(timeoutToCenterMap);
    }
    // re-center the map after the delay or immediately if delay is negative
    if (delay >= 0) {
        timeoutToCenterMap = setTimeout("centerMapAddMarkers();", delay);
    }
    else {
        centerMapAddMarkers();
    }
}

//
// Function: centerMapAddMarkers()
// Center the map using global variables futureMapBounds, futureMapCenter and futureMapZoom
// If futureMapBounds is defined, the center and zoom will be calculated from it
// If futureMapCenter is not defined, the map will be centered to a default location
// Also add the pending markers, if any
//
function centerMapAddMarkers() {
    // if there are bounds defined, calculate the center and zoom
    if (futureMapBounds) {
        futureMapCenter = futureMapBounds.getCenter();
        futureMapZoom = Math.min(map.getBoundsZoomLevel(futureMapBounds), 14);
    }
    // if no center, use the default values
    if (!futureMapCenter) {
        futureMapCenter = new GLatLng(38, -96);
        futureMapZoom = 3;
    }
    
    setLoadingVisibility(true);
    if (map.isLoaded()) {
        addPendingMarkersToMap();
        map.setCenter(futureMapCenter, futureMapZoom);
    }
    else {
        map.setCenter(futureMapCenter, futureMapZoom);
        addPendingMarkersToMap();
    }
}

//
// Function: addPendingMarkersToMap()
// Add all pending markers as map overlays
//
//
function addPendingMarkersToMap() {
    if (markersToAdd) {
      // add all pending markers to the map
      var marker;
      while (marker = markersToAdd.pop()) {
        map.addOverlay(marker);
        totalMarkersInMap++;
      }
    }
    setLoadingVisibility(false);
}


//
// Function: parseKMLFeed(doc, url)
// Process a KML document to get a list of placemarks to overlay to the map.
//
// doc: KML document containing the feed
// url: Original URL from where this document was downloaded
//
// Returns an object with a list of placemarks.
//
function parseKMLFeed(doc, url)
{
    // check for errors
    if (!doc) {
        alert("Error parsing the KML document");
        return null;
    }
    
    // setup return object
    var documentElement = findChild(doc, "Document");
    var parsedDoc = new Object;
    parsedDoc.feedType = "kml";
    parsedDoc.placemarks = new Array();
    parsedDoc.styles = new Object();
    
    // if it is a network link
    var networkLinks = documentElement.getElementsByTagName("NetworkLink");
    if (networkLinks && networkLinks.length) {
        // extract the URL and process that document instead
        var link = findChild(networkLinks[0], "Link");
        if (!link) link = findChild(networkLinks[0], "Url");
        if (link) {
            var href = findChild(link, "href");
            if (href){
                loadMapFromURL(allData(href));
                return "redirected";
            }
        }
    }
    
    // get general document metadata
    var docName = findChild(documentElement, "name");
    if (docName) parsedDoc.name = allData(docName);
    var docDescription = findChild(documentElement, "description");
    if (docDescription) parsedDoc.description = allData(docDescription);
    parsedDoc.baseURL = splitURL(url);
    baseFeedURL = parsedDoc.baseURL;
    
    // get styles
    var styleNodes = documentElement.getElementsByTagName("Style");
    for (var styleIndex=0; styleIndex < styleNodes.length; styleIndex++) {
        var thisStyle = new Object();
        thisStyle.id = styleNodes[styleIndex].getAttribute("id");
        // get the icon style
        var iconStyle = findChild(styleNodes[styleIndex], "IconStyle");
        if (iconStyle) {
            var icon = findChild(iconStyle, "Icon");
            if (icon) {
                var iconHref = findChild(icon, "href");
                if (iconHref) {
                    thisStyle.iconHref = allData(iconHref);
                }
            }
        }
        // add it to the list of styles
        parsedDoc.styles[thisStyle.id] = thisStyle;
    }
    
    // get placemarks
    var placemarks = documentElement.getElementsByTagName("Placemark");
    for (var placemarkIndex=0; placemarkIndex < placemarks.length; placemarkIndex++) {
        var newPlacemark = new Object();
        var validPoint = false;

        // iterate over the placemark elements to get the necessary information
        var placemarkElements = placemarks[placemarkIndex].childNodes;
        for (var pmElemIndex=0; pmElemIndex<placemarkElements.length; pmElemIndex++) {
            if (placemarkElements[pmElemIndex].tagName == "name") {
                newPlacemark.name = allData(placemarkElements[pmElemIndex]);
            }
            else if (placemarkElements[pmElemIndex].tagName == "description") {
                newPlacemark.description = allData(placemarkElements[pmElemIndex]);
            }
            else if (placemarkElements[pmElemIndex].tagName == "styleUrl") {
                newPlacemark.styleUrl = allData(placemarkElements[pmElemIndex]);
            }
            else if (placemarkElements[pmElemIndex].tagName == "Point") {
                var coordinates = findChild(placemarkElements[pmElemIndex], "coordinates");
                if (coordinates) {
                    var latLong = allData(coordinates).split(",");
                    newPlacemark.lat = parseFloat(latLong[1]);
                    newPlacemark.lng = parseFloat(latLong[0]);
                    if (!isNaN(newPlacemark.lat) && !isNaN(newPlacemark.lng)) validPoint = true;
                }
            }
        }
        // if it was a valid placemark, save it
        if (validPoint) parsedDoc.placemarks.push(newPlacemark);        
    }
    
    return parsedDoc;
}


//
// Function: parseXMLFeed(xml, url)
// Process an XML document to get a list of placemarks to overlay to the map.
//
// xml: XML document containing the feed
// url: Original URL from where this document was downloaded
//
// Returns an object with a list of placemarks.
//
function parseXMLFeed(xml, url) {
    // check for errors
    if (!xml) {
        alert("Error parsing the XML document");
        return null;
    }
    
    // Setup return object
    var parsedDoc = new Object;
    parsedDoc.feedType = "xml";
    parsedDoc.placemarks = new Array();
    parsedDoc.styles = new Object();

    // -----------------------------------------
    // Enter your XML parsing code here
    // -----------------------------------------

    // get general document metadata
    var docName = findChild(xml, "name");
    if (docName) parsedDoc.name = allData(docName);
    var docDescription = findChild(xml, "description");
    if (docDescription) parsedDoc.description = allData(docDescription);
    parsedDoc.baseURL = splitURL(url);
    baseFeedURL = parsedDoc.baseURL;



    // -----------------------------------------
    // End XML parsing code
    // -----------------------------------------

    return parsedDoc;
}


//
// Function: parseRSSFeed(rss)
// Process a GeoRSS document to get a list of placemarks to overlay to the map.
//
// rss: RSS feed as an XML document.
//
// Returns an object with a list of placemarks.
//
function parseRSSFeed(rss)
{
    // check for errors
    if (!rss) {
        alert("Error parsing the RSS document");
        return null;
    }
    
    // Setup return object
    var parsedDoc = new Object;
    parsedDoc.feedType = "rss";
    parsedDoc.placemarks = new Array();
    parsedDoc.styles = new Object();
    
    // General map information
    var channel = findChild(rss, "channel");
    if (channel) {
        var mainLinkEl = findChild(channel, "link");
        if (mainLinkEl) {
            parsedDoc.baseURL = splitURL(allData(mainLinkEl));
            baseFeedURL = parsedDoc.baseURL;
        }
        var titleEl = findChild(channel, "title");
        if (titleEl) {
            parsedDoc.name = allData(titleEl);
        }
        var descriptionEl = findChild(channel, "description");
        if (descriptionEl) {
            parsedDoc.description = allData(descriptionEl);
        }
    }

    // Get all item elements.
    // For each element, get title, link, publication date, and geo information
    // Note that all elements of an item are optional.
    var items = rss.getElementsByTagName("item");
    for (var i = 0; i < items.length; i++) {
        item = items[i];
        if (item.nodeName == "item") {

            // if the item doesn't satisfy the filters, don't include it
            if (!itemSatisfiesFilters(item)) continue;
            
            // get the geo information for the item
            var geoInfo = geoInfoForItem(item);

            // we have to have geo information to include the item in the list
            if (geoInfo.hasGeoInfo) {
                var title = findChild(item, "title");
                var link = findChild(item, "link");
                var pubDate = findChild(item, "pubDate");
                // If there's a pubDate element, use it
                if (pubDate) {
                    pubDate = new Date(Date.parse(allData(pubDate)));
                }
                // If not, maybe they're using the Dublin Core date element
                if (pubDate == null) {
                    pubDate = findChild(item, "date", NS_DC);
                    if (pubDate) {
                        var isoDate = allData(pubDate);
                        pubDate = parseISODate(isoDate);
                    }
                }
                var description = findChild(item, "encoded", NS_CONTENT);
                if (!description) {
                    description = findChild(item, "description");
                }

                // create the placemark and store it
                var newPlacemark = {
                    name: title.firstChild.data,
                    link: (link ? allData(link) : null),
                    date: pubDate,
                    description: (description != null ? allData(description) : null),
                    lat: geoInfo.lat,
                    lng: geoInfo.lng,
                    address: geoInfo.address
                }
                parsedDoc.placemarks.push(newPlacemark);
            }
        }
    }

    return parsedDoc;
}

//
// Function: parseAtomFeed(atom)
// Process a GeoAtom feed to get a list of placemarks to overlay to the map.
//
// atom: Atom feed as an XML document.
//
// Returns an object with a list of placemarks.
//
function parseAtomFeed(atom)
{
    // check for errors
    if (!atom) {
        alert("Error parsing the Atom document");
        return null;
    }

    // Setup return object
    var parsedDoc = new Object;
    parsedDoc.feedType = "atom";
    parsedDoc.placemarks = new Array();
    parsedDoc.styles = new Object();
    
    // General map information
    var mainLinkEl = findChild(atom, "link");
    if (mainLinkEl) {
        var href = mainLinkEl.getAttribute("href");
        parsedDoc.baseURL = splitURL(href);
        baseFeedURL = parsedDoc.baseURL;
    }
    var titleEl = findChild(atom, "title");
    if (titleEl) {
        parsedDoc.name = allData(titleEl);
    }

    // For each element, get title, link, publication date, and geo information
    // Note that all elements of an item are optional.
    for (var item = atom.firstChild; item != null; item = item.nextSibling) {
        if (item.nodeName == "entry") {

            // if the item doesn't satisfy the filters, don't include it
            if (!itemSatisfiesFilters(item)) continue;

            // get the geo information for the item
            var geoInfo = geoInfoForItem(item);

            // we have to have geo information to include the item in the list
            if (geoInfo.hasGeoInfo) {
                // Get the title
                var title = atomText(findChild(item, "title"));
                
                // Get the first link
                var link;
                var linkElement = findChild(item, "link");
                if (linkElement) {
                    link = linkElement.getAttribute("href");
                }

                // Try a few different ways to find a date
                var pubDate;
                var updatedElement = findChild(item, "updated");
                if (updatedElement == null) updatedElement = findChild(item, "issued");
                if (updatedElement == null) updatedElement = findChild(item, "modified");
                if (updatedElement == null) updatedElement = findChild(item, "created");
                if (updatedElement) {
                    var isoDate = updatedElement.firstChild.data;
                    pubDate = parseISODate(isoDate);
                }

                var description;
                var descElt = findChild(item, "content");
                if (descElt == null) descElt = findChild(item, "summary");
                if (descElt) {
                    description = atomText(descElt);
                }

                var newPlacemark = {
                    name: title,
                    link: link,
                    date: pubDate,
                    description: description,
                    lat: geoInfo.lat,
                    lng: geoInfo.lng,
                    address: geoInfo.address
                }
                parsedDoc.placemarks.push(newPlacemark);
            }
        }
    }

    return parsedDoc;
}

//
// Function: geoInfoForItem(item)
// Extracts the geo information an item in a feed
//
// item: an XML element representing the item to process
//
// Returns a structure with latitude, longitude and/or address for the item
//
function geoInfoForItem(item) {
    var geoInfo = {
        hasGeoInfo: false,
        lat: null,
        lng: null,
        address: null
    };
    var geoPoint = null;
    var geoWhere = null;
    var geoLat = null;
    // try to get the Geo information in the Simple format
    if (geoPoint = findChild(item, "point", NS_GEORSS)) {
        var latLong = allData(geoPoint).split(" ");
        geoInfo.lat = parseFloat(latLong[0]);
        geoInfo.lng = parseFloat(latLong[1]);
        geoInfo.hasGeoInfo = true;
    }
    // try to get the Geo information in the GML format
    else if (geoWhere = findChild(item, "where", NS_GEORSS)) {
        if (geoPoint = findChild(geoWhere, "Point", NS_GML)) {
            var geoPos = null;
            if (geoPos = findChild(geoPoint, "pos", NS_GML)) {
                var latLong = allData(geoPos).split(" ");
                geoInfo.lat = parseFloat(latLong[0]);
                geoInfo.lng = parseFloat(latLong[1]);
                geoInfo.hasGeoInfo = true;
            }
        }
    }
    // try the GeoBloggers format
    else if(geoPoint = findChild(item, "Point", NS_WGS84)) {
        if (geoLat = findChild(geoPoint, "lat", NS_WGS84)) {
            var geoLong = findChild(geoPoint, "long", NS_WGS84);
            geoInfo.lat = parseFloat(allData(geoLat));
            geoInfo.lng = parseFloat(allData(geoLong));
            geoInfo.hasGeoIanfo = true;
        }
    }
    else if(geoLat = findChild(item, "lat", NS_WGS84)) {
        var geoLong = findChild(item, "long", NS_WGS84);
        geoInfo.lat = parseFloat(allData(geoLat));
        geoInfo.lng = parseFloat(allData(geoLong));
        geoInfo.hasGeoInfo = true;
    }
    // try to get a plain address
    else if(addressNode = findChild(item, "address")) {
        geoInfo.address = allData(addressNode);
        geoInfo.hasGeoInfo = true;
    }
    return geoInfo;
}

//
// Function: itemSatisfiesFilters(item)
// Determine if an item satisfies the predefined filters.
//
// item: DOM element to be evaluated.
//
// Returns true if the item satisfies all filters, false otherwise.
//
function itemSatisfiesFilters(item) {
    var satisfies = true;
    for (var filterIndex = 0; filterIndex < filters.length; filterIndex++) {
        var filter = filters[filterIndex];
        if (!filter || !filter.tag) continue;
        // get the elment from the item to which apply the filter
        var itemFilterNode = findChild(item, filter.tag, filter.namespace);
        if (!itemFilterNode) {
            satisfies = false;
            break;
        }
        var itemFilterValue = allData(itemFilterNode);
        // if it is a numeric filter
        if (filter.type == "int" || filter.type == "float") {
            // convert to number
            if (filter.type == "int") {
                itemFilterValue = parseInt(itemFilterValue);
            }
            else {
                itemFilterValue = parseFloat(itemFilterValue);
            }
            if (isNaN(itemFilterValue)) {
                satisfies = false;
                break;
            }
            // compare agaist the filter
            if (filter.comparison == "min") {
                if (itemFilterValue < filter.value) {
                    satisfies = false;
                    break;
                }
            }
            else if (filter.comparison == "max") {
                if (itemFilterValue > filter.value) {
                    satisfies = false;
                    break;
                }
            }
            else {
                if (itemFilterValue != filter.value) {
                    satisfies = false;
                    break;
                }
            }
        }
        // if it is a string filter
        else {
            if (filter.comparison == "con") {
                if (!itemFilterValue.match(filter.value)) {
                    satisfies = false;
                    break;
                }
            }
            else {
                if (itemFilterValue != filter.value) {
                    satisfies = false;
                    break;
                }
            }
        }
    }
    return satisfies;
}

//
// Function: parseISODate(dateToParse)
// Parse a date string in ISO 8601 format (YYYY-MM-DDTHH:MM:SS+OO:OO) into a Date object.
//
// dateToParse: String containing ISO 8601 date.
//
// Returns a Date object containing the parsed date.
//
function parseISODate(dateToParse)
{
    var returnDate = new Date();

    if (dateToParse && dateToParse.length > 1 && dateToParse.match(/^\d\d\d\d-\d\d-\d\d/)) {
        // separate date and time
        var dateTime=dateToParse.split("T");

        // set the date
        var dateArray = dateTime[0].split("-");
        if (dateArray[1]) returnDate.setMonth(dateArray[1]-1);
        if (dateArray[2]) returnDate.setDate(dateArray[2]);
        if (dateArray[0]) returnDate.setYear(dateArray[0]);

        // split time and offset
        var timeArray = null;
        if (dateTime[1]) timeArray = dateTime[1].match(/(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:([+-])(\d\d):(\d\d))?/);
        if (timeArray) {
            // set the time
            if (timeArray[1]) returnDate.setHours(timeArray[1]);
            if (timeArray[2]) returnDate.setMinutes(timeArray[2]);
            if (timeArray[3]) returnDate.setSeconds(timeArray[3]);

            // add the offset
            if (timeArray[4] && timeArray[5]) {
                var time = returnDate.getTime() - returnDate.getTimezoneOffset() * 60000;
                if (timeArray[4] == "+")
                    time -= timeArray[5] * 3600000;
                else
                    time += timeArray[5] * 3600000;
                returnDate.setTime(time);
            }
        }
    }

    return returnDate;
}

//
// Function: atomText(element)
// Extracts the content of an atom text
//
// element: an Atom element containing an atomTextConstruct per RFC4287
//
// Returns an the text contents of the element
//
function atomText(element)
{
    if (!element) {
        return;
    }

    var textContent;

    var type = element.getAttribute("type");
    if (type && (type.indexOf("xhtml") > -1)) {
        // The spec says there should be a DIV in the XHTML namespace
        var div = findChild(element, "div", NS_XHTML);
        if (div) {
            textContent = div.innerHTML;
        }
    }
    else {
        // Encoded HTML or plain text
        textContent = allData(element);
    }

    return textContent;
}


//
// Function: closeInfoWindow(event)
// Close the info window.
//
// event: onClick event from the clicked button
//
function closeInfoWindow(event)
{
    if (infoWindow) infoWindow.remove();
}

//
// Function: showFullScreen(event)
// Show a full screen window with the marker contents.
//
// event: onClick event from the clicked button
//
function showFullScreen(event) 
{
    if (infoWindow) infoWindow.showFullScreen();
}

//
// Function: showFullScreenImage(event)
// Show a full screen window with the marker contents.
//
// event: onClick event from the clicked button
//
function showFullScreenImage(event) 
{
    if (infoWindow) infoWindow.showFullScreenImage();
}

//
// Function: closeFullScreen(event)
// Close the full screen view.
//
// event: onClick event from the clicked button
//
function closeFullScreen(event)
{
    if (infoWindow) infoWindow.hideFullScreen();
}

//
// Function: zoomOut(event)
// Zoom the map one level out.
//
// event: onClick event from the clicked button
//
function zoomOut(event)
{
    if (map) {
        // if the info window is visible, record its distance to the center
        if (infoWindow && infoWindow.isVisible()) {
            var mapCenter = map.fromLatLngToDivPixel(map.getCenter());
            var infoAnchor = infoWindow.pixelsPoint();
            infoToCenter = new GPoint(mapCenter.x - infoAnchor.x, mapCenter.y - infoAnchor.y);
        }
        map.zoomOut();
    }
}

//
// Function: zoomIn(event)
// Zoom the map one level in.
//
// event: onClick event from the clicked button
//
function zoomIn(event)
{
    if (map) {
        // if the info window is visible, record its distance to the center
        if (infoWindow && infoWindow.isVisible()) {
            var mapCenter = map.fromLatLngToDivPixel(map.getCenter());
            var infoAnchor = infoWindow.pixelsPoint();
            infoToCenter = new GPoint(mapCenter.x - infoAnchor.x, mapCenter.y - infoAnchor.y);
        }
        map.zoomIn();
    }
}

//
// Function: setTypeToMap(event)
// Change the map type to Map.
//
// event: onClick event from the clicked button
//
function setTypeToMap(event)
{
    if (map) {
        map.setMapType(G_NORMAL_MAP);
    }
}


//
// Function: setTypeToSatellite(event)
// Change the map type to Satellite.
//
// event: onClick event from the clicked button
//
function setTypeToSatellite(event)
{
    if (map) {
        map.setMapType(G_SATELLITE_MAP);
    }
}


//
// Function: setTypeToHybrid(event)
// Change the map type to Hybrid.
//
// event: onClick event from the clicked button
//
function setTypeToHybrid(event)
{
    if (map) {
        map.setMapType(G_HYBRID_MAP);
    }
}

//
// Function: setLoadingVisibility(visible)
// Change the visibility of the Loading indicator.
//
// visible: true to show the indicator, false to hide it
//
function setLoadingVisibility(visible) {
    // show or hide the Loading indicator
    var loading = document.getElementById("loading");
    if (visible) {
        pendingRequests++;
        if (loading) {
            loading.style.visibility = "visible";
        }
    }
    else {
        pendingRequests--;
        if (loading && pendingRequests < 1) {
            loading.style.visibility = "hidden";
        }
    }
}

//
// Function: splitURL(url)
// Split components of the URL (protocol, domain, resource)
//
// url: URL to split
//
function splitURL(url)
{
    var baseURL = { protocol: "", domain: "", resource: "" };

    if (!url || url.length == 0) return baseURL;
    var components = url.split("://");
    baseURL.protocol = components[0];
    var slashIndex = components[1].indexOf("/");
    if (slashIndex >= 0) {
        baseURL.domain = components[1].substring(0, slashIndex);
        baseURL.resource = components[1].substring(slashIndex + 1, components[1].length);
    }
    else {
        baseURL.domain = components[1];
    }

    return baseURL;
}

//
// Function: allData(node)
// Concatenate all the text data of a node's children.
//
// node: DOM element to search for text.
//
// Returns the concatenated text.
//
function allData(node)
{
    var data = "";
    node = node.firstChild;
    if (node) {
        if (node.data) data += node.data;
        while (node = node.nextSibling) {
            if (node.data) data += node.data;
        }
    }

    return data;
}


//
// Function: fixLinks(htmlFragment)
// Update hyperlinks in a document fragment to use the openURL function.
//
// htmlFragment: DOM element in which to adjust links.
//
function fixLinks(htmlFragment)
{
    // Collect all the links
    var links = htmlFragment.getElementsByTagName("a");
    for (var i = 0; i < links.length; i++) {
        var aNode = links[i];
        var href = aNode.getAttribute("href");
        // Make it absolute if it isn't already
        if (href.indexOf(":") < 0) {
            aNode.setAttribute("href", absoluteURL(href));
        }

        // Send them to our clickOnLink function
        aNode.addEventListener("click", clickOnLink, false);
    }
}

//
// Function: absoluteURL(url)
// Convert a relative URL into an absolute one using the global base URL
//
// url: Relative URL to convert.
//
// Returns the absolute URL.
//
function absoluteURL(url, splittedBase)
{
    if (!baseFeedURL) {
        return url;
    }

    var baseURL = baseFeedURL.protocol + "://" + baseFeedURL.domain;
    // if it is absolute within the domain
    if (url.indexOf("/") == 0) url = baseURL + url;
    // if it is relative to the current resorce
    else url = baseURL + "/" + baseFeedURL.resource + url;
    return url;
}

//
// Function: clickOnLink()
// Called from onClick to open a link in the browser instead of in the widget.
//
function clickOnLink(e)
{
    if (e && window.widget) {
        var linkEl = e.currentTarget;
        if (linkEl && linkEl.href) {
            widget.openURL(linkEl.href);
        }
        e.stopPropagation();
        e.preventDefault();
    }
    return false;
}


//
// Function: findChild(element, nodeName, namespace)
// Scans the children of a given DOM element for a node matching nodeName, optionally in a given namespace.
//
// element: The DOM element to search.
// nodeName: The node name to search for.
// namespace: Optional namespace the node name must be in.
//
// Returns the child node if found, otherwise null.
//
function findChild(element, nodeName, namespace)
{
    var child;

    for (child = element.firstChild; child != null; child = child.nextSibling) {
        if (child.localName == nodeName) {
            if (namespace == null || child.namespaceURI == namespace)
                return child;
        }
    }

    return null;
}

//
// Function: load()
// Called by HTML body element's onload event when the widget is ready to start
//
function load()
{
    dashcode.setupParts();
    
    // initialize variables
    filters = new Array();
    pendingRequests = 0;
    showCalled = false;
    
    // determine if the map has a custom title
    hasCustomTitle = false;
    var titleEl = document.getElementById("title");
    if (titleEl) {
        if(titleEl.innerHTML.length && titleEl.innerHTML != "Kartentitel wird hier angezeigt  ") {
            hasCustomTitle = true;
        }
        else {
            titleEl.innerHTML = "";
        }
    }

    // if no key was specified, show error message
    if (!attributes.googleMapsKey || attributes.googleMapsKey.length == 0) {
        displayErrorMessage(dashcode.getLocalizedString("Karten-API-SchlÃ¼ssel in den Widget-Attributen festlegen."), true);
    }
    else {
        // if the Maps API was successfully loaded, setup the map
        if (typeof(GMap2) != "undefined") {
            setupMap();
        }
        // else show an error message
        else {
            displayErrorMessage(dashcode.getLocalizedString("Fehler beim Laden des Karten-API."));
        }
    }
}

//
// Function: setupMap()
// Create the map and set its initial attributes
//
function setupMap() {
    // create and configure the map and geocoder
    var mapDiv = document.getElementById("map");
    map = new GMap2(mapDiv);
    map.enableDoubleClickZoom();
    geocoder = new GClientGeocoder();

    // set default center and zoom level
    setLoadingVisibility(true);    
    futureMapBounds = null;
    futureMapCenter = new GLatLng(38, -96);
    futureMapZoom = 3;
    delayedCenterMapAddMarkers(500);

    // map load event handler
    GEvent.addListener(map, "load", function() {
        // create the info window
        var infoWindowDiv = document.getElementById("infoWindow");
        if (infoWindowDiv) {
            infoWindow = new InfoWindow(map, infoWindowDiv);
        }
        
        // fix links on the map
        fixLinks(map.getContainer());
        
        // hide the Loading indicator
        setLoadingVisibility(false);
    });
    
    // map click event handler
    GEvent.addListener(map, "click", function(overlay, latLongPoint) {
        // if the click was not on a marker or overlay, hide the info window
        if (!overlay && infoWindow && infoWindow.isVisible()) {
            var clickedPoint = map.fromLatLngToDivPixel(latLongPoint);
            if (clickedPoint && !infoWindow.containsPoint(clickedPoint)) {
                closeInfoWindow();
            }
        }
    });
    
    // map zoom end event handler
    GEvent.addListener(map, "zoomend", function(oldZoom, newZoom) {
        // if the info window is visible, make the marker remain in the same position
        if (infoWindow && infoWindow.isVisible() && infoToCenter) {
            var infoAnchor = infoWindow.pixelsPoint();
            var newCenter = new GPoint(infoAnchor.x + infoToCenter.x, infoAnchor.y + infoToCenter.y);
            map.setCenter(map.fromDivPixelToLatLng(newCenter));
            infoToCenter = null;
        }
    });
}

//
// Function: getMapsKey(event) 
// Go to the Maps API page to get a developer key.
//
function getMapsKey(event) {
    if (widget) {
        widget.openURL("http://www.google.com/apis/maps/signup.html");
    }
}

//
// Function: setFilterExact(event)
// Create a filter with an '=' comparison from a text field.
//
function setFilterExact(event) {
    updateFilter(event.currentTarget);
}

//
// Function: setFilterContains(event)
// Create a filter with a 'contains' comparison from a text field.
//
function setFilterContains(event) {
    updateFilter(event.currentTarget, "con");
}

//
// Function: setFilterMin(event)
// Create a filter with a '>=' comparison from a text field.
//
function setFilterMin(event) {
    updateFilter(event.currentTarget, "min");
}

//
// Function: setFilterMax(event)
// Create a filter with a '<=' comparison from a text field.
//
function setFilterMax(event) {
    updateFilter(event.currentTarget, "max");
}

//
// Function: updateFilter(name, comparison)
// Update a filter for the map points.
//
function updateFilter(element, comparison) {
    if (!element) {
        return false;
    }
    // get the filter information
    var filterValue = element.value;
    var filterName = element.name;
    var newFilter = null;
    var oldFilterIndex = -1;
    
    // find the old filter
    for (var f=0; f < filters.length; f++) {
        if (filters[f].tag == filterName && filters[f].comparison == comparison) {
            oldFilterIndex = f;
            break;
        }
    }

    // if there is a value for the filter
    if (filterValue.length) {
        // create the filter
        // use the input text element's id as the tag to look for
        newFilter = new Object();
        newFilter.tag = filterName;
        newFilter.comparison = comparison;
        newFilter.value = filterValue;
        // determine the type
        newFilter.type = "string";
        var intValue = parseInt(filterValue);
        if (!isNaN(intValue)) {
            if (filterValue.indexOf(".") >-1 ) {
                newFilter.value = parseFloat(filterValue);
                newFilter.type = "float";
            }
            else {
                newFilter.value = intValue;
                newFilter.type = "int";
            }
        }
        // if the coparison is 'contains', use a case-insensitive regular expression
        else if (comparison == "con") {
            newFilter.value = new RegExp(filterValue, "i");
        }
        // save it into the filters array
        filters.push(newFilter);
        // if no old filter or value changed, reload the map
        if (oldFilterIndex < 0 || filters[oldFilterIndex].value != newFilter.value) {
            shouldReloadMap = true;
        }
    }

    // if the filter existed
    if (oldFilterIndex > -1) {
        filters.splice(oldFilterIndex, 1);
        if (!newFilter) {
            shouldReloadMap = true;
        }
    }
}

//
// Function: remove()
// Called when the widget has been removed from the Dashboard
//
function remove()
{
    // your widget has just been removed from the layer
    // remove any preferences as needed
    // widget.setPreferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));

    // unload the map
    if (typeof(GUnload) != "undefined") {
        GUnload();
    }
}

//
// Function: hide()
// Called when the widget has been hidden
//
function hide()
{
    // your widget has just been hidden stop any timers to
    // prevent cpu usage
}

//
// Function: show()
// Called when the widget has been shown
//
function show()
{
    // your widget has just been shown.  restart any timers
    // and adjust your interface as needed

    // We do this in show() instead of load() or setupMap() because it may take a long time,
    // blocking all execution. By doing it here, the map can be loaded and displayed before
    // the feed is loaded and parsed.
    if (!showCalled && map) {
        // load the overlay map from a url
        if (attributes.mapURL && attributes.mapURL.length) {
            // make sure the map is loaded and initialized (centered) before adding markers
            delayedCenterMapAddMarkers(-1);
            loadMapFromURL(attributes.mapURL);
        }
        // if initial address is specified, go there
        else if (attributes.initialAddress && attributes.initialAddress.length) {
            goToAddress(attributes.initialAddress);
        }
    }
    showCalled = true;
}

//
// Function: sync()
// Called when the widget has been synchronized with .Mac
//
function sync()
{
    // your widget has just been synchronized with .Mac
    // retrieve any preference values that you need to be synchronized here, use this for an instance key's value :
    // instancePreferenceValue = widget.preferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
    //
    // or this for global key's value :
    // globalPreferenceValue = widget.preferenceForKey(null, "your-key");    
}

//
// Function: showBack(event)
// Called when the info button is clicked to show the back of the widget
//
// event: onClick event from the info button
//
function showBack(event)
{
    // your widget needs to show the back

    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (window.widget)
        widget.prepareForTransition("ToBack");

    front.style.display="none";
    back.style.display="block";
    
    if (window.widget)
        setTimeout('widget.performTransition();', 0);
}

//
// Function: showFront(event)
// Called when the done button is clicked from the back of the widget
//
// event: onClick event from the done button
//
function showFront(event)
{
    // your widget needs to show the front

    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (window.widget)
        widget.prepareForTransition("ToFront");

    front.style.display="block";
    back.style.display="none";
    
    if (window.widget)
        setTimeout('widget.performTransition();', 0);

    // reload the map if necessary
    if (shouldReloadMap) {
        shouldReloadMap = false;
        loadMapFromURL(attributes.mapURL);
    }
}

// Initialize the Dashboard event handlers
if (window.widget)
{
    widget.onremove = remove;
    widget.onhide = hide;
    widget.onshow = show;
    widget.onsync = sync;
}
